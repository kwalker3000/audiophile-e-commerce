import React, { useState, useEffect } from 'react'
import Head from 'next/head'

import { loadStripe } from '@stripe/stripe-js'
import { Elements, useStripe } from '@stripe/react-stripe-js'

import { finalizeOrder } from '../lib/finalizeOrder'
import { createGuestOrderLog } from '../lib/createGuestOrderLog'

import styles from '../styles/modules/Checkout.module.css'

import { CheckoutHeader } from '../src/components/Checkout/CheckoutHeader'
import { Stepper } from '../src/components/Checkout/Stepper'
import { Footer } from '../src/components/Footer/Footer'

import { Map } from '../src/components/Success/Map'
import { MapOverlay } from '../src/components/Success/MapOverlay'

import { useAppContext } from '../src/context/appContext'

import { parseCookies, setCookie } from 'nookies'

// Make sure to call loadStripe outside of a componentâ€™s render to avoid
// recreating the Stripe object on every render.
// This is your test publishable API key.
const stripePromise = loadStripe(
  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,
  {
    betas: ['process_order_beta_1'],
    apiVersion: '2020-08-27; orders_beta=v4',
  }
)

let img = '../public/assets/map/map-marker.png'

export default function OrderStatusPage({ token, store, user }) {

    let { address } = useAppContext();

  const [isLoading, setIsLoading] = useState(true)
    const [userData, setUserData] = useState({
        name: address.name,
        address: {
            city: address.city,
            country: address.country,
            postal_code: address.zip,
        },
        coord: {
            lon: null,
            lat: null
        }
    })
    const [storeData, setStoreData] = useState({
        id: null,
        country_code: "",
        postal_code: "",
        city: "",
        lat: null,
        lon: null
    })

  let removeOverlay = () => {
    setIsLoading(false)
  }

    useEffect(() => {

        // store will be set to 0 if user is 'guest'
        if (store == 0) {
	    let cookies = parseCookies()
	    let { guest } = cookies
	    guest = JSON.parse(guest)

            let getShippingData = async (guest) => {

		let data = await createGuestOrderLog(guest)
                return data
            }

            getShippingData(guest)
                .then(res => {
                    setStoreData(res)
                })
	    setUserData(prevData => ({...prevData, coord: {
                lon: guest.coord.lon,
                lat: guest.coord.lat
            }}))

        }
        else {
            setUserData(prevData => ({...prevData, coord: {
                lon: user.coord.lon,
                lat: user.coord.lat
            }}))
            setStoreData(store)
        }
	
    }, [])

  return (
    <div className={styles.page}>
      <Head>
        <title>Checkout | Audiophile</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Elements stripe={stripePromise}>
        <header className={styles.pageHeader}>
          <CheckoutHeader />
        </header>

        <main className={styles.main}>
          <div className={`${styles.mainGrid} ${styles.grid}`}>
            <section className={styles.gridStepper}>
              <Stepper />
            </section>

            <section className={styles.gridSummary}>
              <div></div>
            </section>

            <section
              className={styles.gridForm}
              style={{
                position: 'relative',
                /* width: '400px', */
                height: '400px',
              }}
            >
              { isLoading &&
                <MapOverlay />}
              { userData.coord.lon &&
                <Map
                  token={token}
                  store={storeData}
                  user={userData}
                  removeOverlay={removeOverlay}/>}
              <OrderStatus />
            </section>
          </div>
        </main>

        <footer className={styles.pageFooter}>
          <Footer />
        </footer>
      </Elements>
    </div>
  )
}

export async function getServerSideProps(ctx) {
  const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY, {
    apiVersion: '2020-08-27; orders_beta=v4',
  });

    let { authOptions } = require('./api/auth/[...nextauth]');
    let { unstable_getServerSession } = require('next-auth/next');

    let session = await unstable_getServerSession(ctx.req, ctx.res, authOptions);

    let token = process.env.MAPBOX_TOKEN;

    let orderData

    let getData = async () => {
        
	if (session) {
     
	    let data = await finalizeOrder(session.user.id)
	    let { store, orderLog } = data

	    let order = await stripe.orders.retrieve(orderLog.stripe_order)

            return { store, order, orderLog}
	}
        else {
            let store = 0
            let orderLog = {
                lon: 0,
                lat: 0
            }
            
            return {store, orderLog}
        }

    }
    
    let { store, order, orderLog } = await getData()
    console.log(store)
    console.log(order)
    console.log(orderLog)

  return {
    props: {
      token,
        store,
        user: {
            coord: {
                lon: orderLog.lon,
                lat: orderLog.lat
            },
        },
    },
  }
}

function OrderStatus() {
  let { emptyCart } = useAppContext()
  const stripe = useStripe()
  const [message, setMessage] = useState(null)
  useEffect(() => {
    ;(async () => {
      if (!stripe) {
        return
      }

      const clientSecret = new URLSearchParams(window.location.search).get(
        'order_client_secret'
      )

      stripe.retrieveOrder(clientSecret).then(({ order }) => {
        switch (order.payment.payment_intent.status) {
          case 'succeeded':
            // TODO order_id and product_id associative table
            emptyCart()
            setMessage('Payment succeeded!')
            break
          case 'processing':
            setMessage('Your payment is processing.')
            break
          case 'requires_payment_method':
            setMessage('Your payment was not successful, please try again.')
            break
          default:
            setMessage('Something went wrong.')
            break
        }
      })
    })()
  }, [stripe])

  return (
    <>
      {/* Show any error or success messages */}
      {message && <div id="payment-message">{message}</div>}
    </>
  )
}
